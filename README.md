## Задание 1. Сложность, тестирование, особые случаи - 10 из 10.

**Температура помещения.** Кондиционер регулирует температуру в зависимости от режима работы. Условная конструкция, чтение и запись в консоли.  
Сложность = O(1).  
</br>
**Существует ли треугольник.** По сторонам определить можно ли построить треугольник. Сумма двух сторон больше другой стороны.  
Сложность = O(1).  
</br>
**Решение уравнения.** Дано уравнение, определить все решения. Проверка входных данных на область допустимых значений (ОДЗ). Много проверок и математические операции.  
Сложность = O(1).  
</br>
**Расстановка ноутбуков.** Определить минимальный размер стола для расстановки ноутбуков. Перебор всех пар сторон для определения минимальной площади стола.  
Сложность = O(1).  
</br>
**Изготовка деталей.** Определить сколько деталей можно изготовить из доступного сплава. Проверка на несоответствие стоимости загатовки и детали, определение доступного количества загатовок и деталей, распределение остатка материала в цикле.  
Сложность = O(1).  
</br>
**Время поездов.** Определить времени ожидания всех поездов. Рассчет максимального и минимального времени ожидания на платформе для каждого поезда, проверка на сходимость решения, определение пересечения отрезков. Минимум ожидания для N поездов - простоять N минут и провести N-1 интервал в ожидании, а максимум для ожидания N поездов - простоять N минут и провести N+1 интервал в ожидании.  
Сложность = O(1).  
</br>
**Перемещение предмета через отверстие.** Определить возможно ли переместить кирпич через дырку.
   1) Перебор возможного поворота предмета для перемещения через отверстие.  
      Сложность = O(1).
   2) Сортировка сторон отверстия и предмета с помощью сортировки пузырьком, сравнение пар наименьших сторон.

**Соответствие номера телефона.** Определение на соответствие номера телефона каждому номеру из списка контактов. Перебор в цикле номеров из списка контактов; нормализация всех номеров: удаление всех символов кроме пробелов, удаление кода страны, добавление кода региона при отсутствии.  
Сложность = O(1).  
</br>
**Решение СЛАУ из 2 уравнений.** Определить вид вырожденного случая СЛАУ и значения неизвестных. Определение правильного порядка ввода данных; вычисление определите; определение вида вырожденного случая: все коэффициенты нулевые, одна строка пустая, некоторые коэффициенты равны нулю, пропорциональные строки; рашение СЛАУ методом Крамера. Сравнение float с нулем с помощью эпсилон; сравнение float чисел с помощью эпсилон, избегание деления на 0 с помощью умножения крестом.  
Сложность = O(1).  
</br>
**Определение номер этажа.** Определить номер этажа и подъезда квартиры по имеющейся информации о второй квартире. 
   1) Перебор количества квартир на этаже в цикле (до максимального номера квартиры), проверка на сходимость значения по имеющимся данным о другой квартире, проверка на корректность введенных данных. Удалять лишие проверки, так как может возникнуть ошибка. Сброс номера подъезда и этажа при нескольких подходящих ответах.  
      Сложность = O(max(K1, K2)).
   2) Определить диапазон количества квартир на этаже с помощью математического анализа. Не перебирать все значения из диапазона, а только границы. 


</br></br></br></br>

## Задание 2. Линейный поиск - 10 из 10.

**Возрастающий ли список.** Определить является ли список монотонно возрастающим (каждый элемент больше предыдущего). Перебор всех элементов и проверка на возрастание с помощью флага.  
Сложность = O(N).  
</br>
**Вид последовательности.** Определить вид последовательности. Перебор всех элементов в каждой проверке и изменение флага типа последовательности.  
Сложность = O(N).  
</br>
**Ближайшее число.** Определить самый близкий по величине элемент к числу. Перебор всех элементов, модуль разницы, сохранение минимальной разницы в переменную.  
Сложность = O(N).  
</br>
**Больше соседей.** Определить количество элементов, которые больше двух соседних. Перебор всех элементов от 1 до N-1, увеличение счетчика.  
Сложность = O(N).  
</br>
**Место в чемпионате.** Определить максимальное место участника согласно условию (до него 1 место и дальность броска оканчивалась на 5). Начальный максимум - нулевой элемент, определение максимума и сброс места, проверка условий и определение наибольшего из подходящих мест, подсчет места в соревновании.  
Сложность = O(N).  
</br>
**Симметричная последовательность.** Определить симметрична ли последовательность, если нет определить какие значения нужно добавить для симметричности. Смещение левого указателя для определения недостающих значений, правый указатель сбрасывается к начальному положению для определения симметричности, работаем с индексами последовательности (начальное значение -1).  
Сложность = O(N).  
</br>
**Наибольшее произведение 2 чисел.** Определить максимальное произведение двух чисел. Максимальное произведение двух чисел - произведение 2 минимальных значений (отрицательных) или произведение 2 максимальных чисел последовательности. Начальные значения - первые два элемента, проход по циклу и определение первого и второго минимума и максимума, сравнение произведений минимумов и максимумов.  
Сложность = O(N).  
</br>
**Наибольшее произведение 3 чисел.** Определить максимальное произведение трех чисел. Максимальное произведение двух чисел - произведение 2 минимальных значений (отрицательных) и одного максимального или произведение 3 максимальных чисел последовательности.
   1) Начальные значения - макисмальное и минимальное значение типа данных; проход по циклу; определение первого и второго минимума; определение первого, второго и третьего максимума; сравнение произведений минимумов с максимумом и 3 максимумов.  
      Сложность = O(N).
   2) Сортировка пузырьком (для 3 максимумов и 2 минимумов) или быстрая сортировка с поиском k-порядка статистики.

**Построение поля для сапера.** Построение поля для игры "Сапер" по минам. Инициализация поля для игры, определение индексов соседей, проход по всем минам и заполнение соседей, установка мин, вывод с обработкой мин (замена -1 на *).  
Сложность = O(N * M + K) = O(N^2).  
</br>
**Горячо-холодно.** Определение диапазона частоты звука по измерениям (частота и признаку сравнения с предыдущим измерением). Установка начального диапазона, пробег по всем измерениям с учетом точности, 
сдвиг границ по показаниям.  
Сложность = O(N).  
</br>

</br></br></br></br>

## Задание 3. Множества - 10 из 10.

**Количество различных чисел.** Определить количество различных чисел. Преобразование исходного списка в множество, таким образом сохраняются только уникальные значения.    
Сложность = O(N).  
</br>
**Общие числа в списках.** Определить общие числа в двух множествах. 
   1) Преобразование исходных списков в множества; пересечение двух множеств для поиска общих чисел; создается отдельное множество с числами, которые есть в обоих множествах; сортировка получившегося множества.  
      Сложность = O(N + M + K * logK).  
   2) Преобразование наименьшего списка в множество, пробег по другому списку с помощью фильтрации, удаление дубликатов, сортировка.
      Сложность такая же, но чуть меньше используется памяти.  

**Общие и уникальные цвета кубиков.** Определить общие и уникальные цвета в двух списках. 
   1) Преобразование исходных списков в множества; пересечение двух множеств для поиска общих цветов; разность двух множеств для поиска уникальных цветов; создается отдельное множество с цветами, которые есть в обоих множествах, и для уникальных цветов тоже; сортировка получившихся множеств.  
      Сложность = O(N + M + (K + P + L) * log(max(K, P, L)).  
   2) Сохранение сразу двух множеств для всех задач, проход по циклу одного множества для определения общих цветов и уникальных цветов для текущего множества, проход по циклу другого множества для определения уникальных цветов.
      Сложность = O(N * logN + M * logM).

**Недостающие кнопки.** Определить минимальное количество кнопок для добавления, чтобы ввести число на клавиатуре. 
   1) Преобразование числа в множество уникальных символов, определение недостоющих клавиш с помощью разности множеств.    
      Сложность = O(1).
   2) Одно множеством кнопок, определение цифр числа делением на 10, добавление в множество недостающих цифр, проверка на число 0.

**Количество схожих пар букв.** Определить количество пар соседних оснований в строке, которые встречаются во второй строке. Получение списка всех пар из первой строки, получение множества уникальных пар второй строки, пробег по всем парам первого списка для подсчета вхождений во второе множество.    
Сложность = O(N + M).  
</br>
**Правдивые места.** Определить количество человек, которые говорят правдивые места. 
   1) Создание множества всех возможных мест, объединение множеств сказанных мест и возможных, определение размера объединенного множества.    
      Сложность = O(N).
   2) Создание множества правильно сказанные мест, множество - исключает повторение, пробег по всем сказанным местам, определение правды с помощью: Сумма мест = Число участников - 1, сохранение только одного значения из двух в множестве, определение размера множества.  
    
**Число выстрелов.** Определить минимальное количество выстрелов, чтобы сбить всех птиц. Птицы при падении сбивают птиц снизу. Определение множества координат по оси X на которой находятся птицы, множество - уникальные коопдинаты по оси X. Каждый выстрел должен сбивать самую верхнюю птицу (максимум по оси Y) в каждой координате X.   
Сложность = O(N).  
</br>
**Количество различных слов.** Определить количество различных слов в тексте. Слово - последовательность непробельных символов идущих подряд, слова разделены одним или большим числом пробелов или символами конца строки. Разные регистры - разные слова. Разделение слов по нескольким пробелам, табулиции переносу строки; проверка, что слово содержит один не пробельный символ; сохранение слов в множество для сохранения уникальных слов; размер множества.  
Сложность = O(L).  
</br>
**Количество языков.** Определить языки и их количество, которые знают все школьники и хотя бы один школьник.  
   1) Все школьники - пересечение всех множеств языков, который знает определенные студент; хотя бы один школьник - объединение всех множеств языков, который знает определенные студент.  
      Сложность = O(N * M).
   2) При пересечении для оптимизации можно отсортировать, чтобы пробегать по меньшему числу языков. Выйти из цикла, если множество при пересечении стало пустым.  

**Координаты по навигатору.** Определить возможное местонахождение по информации с навигатора. У навигатора есть точность и время в пути. Корректировка местоположения на каждой точке отсчета с помощью диагоналей, перебор значений диагоналей, определение координат благодаря значениям диагоналей, проверка на корректность координат.  
Сложность = O(N + M^2).  
</br>


</br></br></br></br>

## Задание 4. Словари и сортировка подсчетом - 10 из 10.

**Определить синоним.** Определить синоним к указанному слову. Определить словарь с ключом - слово, а значение - синоним; каждую пару слов добавлять 2 раза, чтобы сохранять в качестве ключа все слова; производить поиск по ключу.  
Сложность = O(N).  
</br>
**Самое частое слово.** Определить слово, которое встречается чаще с учетом регистра (если несколько, то сравнить по лексикографическому порядку). 
   1) Удалить несколько пробелов и перевод строки, разбить строку на слова и преобразовать в список; сохранять в словарь, где ключ - слово, а значение - число повторений; определить максимальное число повторений; отфильтровать значения по максимальному числу повторений; найти минимальную строку по лексикографическому порядку в списке.  
      Сложность = O(L).
   2) Разбить по символам пробелов и переводу строки, отфильтровать пустые строки, за 1 проход добавлять в словарь, смотреть частоту слова, отслеживать максимальную частоту слова, сохранять слово с максимальной частотой и минимальным лексикографическим порядком.   

**Время жизни клавиш.** Определить клавиши, которые сломаются в процессе работы. Определить словарь с ключом - клавиша, а значение - количество нажатий; пробег по всем клавишам со временем жизни; сравнение числа нажатий и времени жизни; сохранение состояния работы в список для каждой клавиши.  
Сложность = O(K + N).  
</br>
**Операции с балансом.** Операции с счетом в банке, в зависимости от операции выполняются разные действия с балансом. Разбить строку на тип операции, клиента и сумму; определить словарь с ключом - имя клиента, а значение - сумма на балансе; реализована разная логика для разных операций.  
Сложность = O(N * M).  
</br>

**Расшифровка сообщения.** Определить количество вхождений последовательности символов в текст.  
   1) Определение символов и их количества в исходном слове с помощью словаря; определение символов и их количества в текущей последовательности текста с помощью словаря; определение степени сходства слова и последовательности; сдвиг окна - первый символ уходит из последовательности, следующий символ появляется в последовательности; изменение степени сходства исходя из ухода и призода символов; подсчет количества вхождений слова в текст (равенство сходства и размера словаря).   
      Сложность = O(N * M).
   2) Вместо словаря сортировать слово и часть строки и сравнивать, но нужно будет постоянно заново сортировать при сдвиге окна.
   3) Использовать сортировку подсчетом вместо словаря для определение символов и их количества в последовательности текста и слове.  

**Номер появления слова.** Определить сколько раз слово встречалось ранее. Слово - последовательность непробельных символов идущих подряд, слова разделены одним или большим числом пробелов или символами конца строки. 
   1) Разбиение текста на слова с помощью регулярного выражения; фильтрация пустых слов; проход по всем словам; словарь для определения номера появления, ключ - слово, а значение - номер появления; формирование списка для вывода; конвертация списка в строку.  
      Сложность = O(L).
   2) Можно обрабатывать строку как последовательность, чтобы не хранить текст целиком (для экономии памяти).  

**Максимальная высота пирамиды.** Определить максимальную высоту пирамиды, если блок может стоять только на блоке с большей шириной. Пробег по всем блокам; определение блоков для пирамиды с помощью словаря, ключ - ширина блока, а значение - высота; проверка что ширина не встречалась или была меньше высота у блока с текущей шириной; сумма высот в Long (для избежание переполнения суммы Int).  
Сложность = O(N).  
</br>
**Ошибки в ударениях.** Определить количество ошибок в поставленных ударениях. Правильное ударение: если есть в словаре и, если в словаре отсутствует то поставленно только одно ударение (даже на согласную). Формирование словаря, где ключ - исходное слово без ударений, а значение - множество со всеми ударениями; получение слов из текста; проход по всем словам; перевод слова в нижний регистр (без ударений); проверка есть ли слово в словаре; сходится ли ударение со словарем; определение числа ударений в слове; счетчик ошибок в ударениях.   
Сложность = O(N + L).  
</br>
**Список покупок.** Определить список товаров и их количества для каждого покупателя. Использование словаря TreeMap для автоматической сортировки при добавлении; чтение файла в буфер для экономии памяти и быстрого выполнения; разбиение строки на слова по символу (вместо строки), так как быстрее; для оптимизации формирования вывода использовался StringBuilder. Можно оптимизировать разбиение строки на слова, чтобы не создавать каждый раз список слов. Словарь для списка покупок, где ключ - имя покупателя, а значение - отсортированный словарь (ключ - продукт, значение - количество).   
Сложность = O(N * logM + N * logK).  
</br>
**Частота использования идентификаторов.** Определить наиболее частый используемый идентификатор. Идентификатор - последовательность из латинских букв, цифр и знаков подчеркивания, которые не являются ключевыми словами и содержат хотя бы один символ, не являющийся цифрой. Язык может быть чувствителен к регистру и идентификатор начинаться с цифры. Определение ключевых слов в множестве в зависимости от чувствительности языка к регистру; считывание оставшихся строк файла как программы; замена символов отличных от букв, цифр и знаков подчеркивания на пробел; получение всех идентификаторов разбиением кода программы пробелами; фильтрация пустых идентификаторов; проверка на отсутствие идентификаторов. Пробег по всем идентификаторам; преобразование идентификатора в зависимости от чувствительности языка к регистру; проверка является ли идентификатор ключевым словом; проверка на первую цифру и что все символы цифры в идентификаторе; подсчет частоты идентификатора в коде с помощью словаря (ключ - идентификатор, значение - количество употреблений); определение максимальной частоты употребления идентификатора; получение первого встречающегося идентификатора с максимальной частотой с помощью LinkedHashMap (сохраняется порядок добавления).  
Сложность = O(L + N * S + K).  
</br>


</br></br></br></br>

## Задание 5. Префиксные суммы и два указателя - 10 из 10.

**Минимальная разница чисел.** Определить наиболее стильные штаны и майку. Стильность одежды тем больше, чем меньше разница в цвете элементов его одежды.
   1) Определены два уазателя для двух разных списков; первый указатель - индекс цвета майки, второй указатель - индекс цвета штанов; определение минимальной разницы цветов; сдвиг второго указателя, если цвет штанов меньше цвета футболки, иначе двигаем первый указатель (подбираем лучший цвет если это возможно иначе переходим на следующую итерацию).   
      Сложность = O(N + M).  
   2) Можно проверять на разницу 0 и сразу выходить, так как стилней вещи уже не подобрать.  

**Сумма номеров.** Определить количество интервалов, где сумма элементов равна определенному числу.
   1) Определены два уазателя: левый указатель - индекс начала интервала, правый указатель - индекс конца интервала; сдвиг правого указателя на каждой итерации; сдвиг левого указателя, если сумма оказалась больше числа; проверка, чтобы левый указатель не превышал правый; увеличивать счетчик при сумме равной числу.   
      Сложность = O(N).  
   2) Можно использовать префикс-суммы для суммы элементов массивов на каждом индексе; и потом бегать второй цикл пл префикс-сумме.  

**Высота подъема пути.** Определить суммарную высоту подъемов на каждом пути. Величина подъема - разность высот между начальной и конечной точками участка. Определение префиксной суммы для высоты подъема при прямом ходе; определение префиксной суммы для высоты подъема при обратном ходе; расчет суммарной высоты подъемов от точки старта до точки финиша по префиксной сумме.   
Сложность = O(N + M).  
</br>
**Количество пар с допустимым расстоянием.** Определить число способов организовать встречу, чтобы люди не пересекались друг с другом в точках с указанной видимостью на улице. Определение префиксной суммы для расстояние между i и первым памятником; счетчик способов; правый указатель - минимальный допустимый памятник; левый указатель - памятник для перебора точки встречи; при изменении счетчика учитываются и более правые памятники, так как они точно подходят, расстояние только увеличивается, т.к. массив отсортирован; сдвиг правого указателя, если расстояния между памятниками недостаточно.     
Сложность = O(N).  
</br>
**Минимальный отрезок со всеми вариациями.** Определить координаты левого и правого концов отрезка минимальной длины, удовлетворяющего условию - каждый вид деревьев сохранится минимум в одном экземпляре. Минимальный отрезок - количество видов, чтобы сохранить их все. Массив количество вхождений (размер = кол-во вариаций) определенного вида в отрезок; подсчет на начальном отрезке числа видов, если все сохранились - выходим; счетчик для подсчета количество сортов в отрезке; сохраняем глобальную и локальную минимальную длину подходящего отрезка; сдвиг правого указателя до конца в цикле, если все сорта вошли в отрезок, то двигаем левый указатель; при движении указателей изменяем число сортов в отрезке; и постоянно проверяем на минимульную длину отрезка.    
Сложность = O(N).  
</br>
**Общая стоимость кондиционеров.** Определить минимальную суммарную стоимость кондиционеров в рублях для всех классов. 
   1) Сортируем классы по требованиям к кондиционерам; сортируем кондиционеры по стоимости; двигаем указатель по всем классам; проверка, что текущий кондиционер соответствует требованиям текущего класса, иначе берем другой кондиционер (двигаем указатель на кондиционеры); рассчитываем общую стоимость, если кондиционер подходит по условиям.    
      Сложность = O(N * logN + M * logM).
   2) Префиксная сумма минимальной стоимости кондиционера для каждой мощности; массив размером maxB (1000); определяем минимальную стоимость для каждого кондиционера; проходим обратным способом по префиксным суммам и находим минимум между предыдущей и текущей стоимсотью. Проблема, что не для каждой мощности есть кондиционер; но решается указанием начальной цены MaxInteger и нахождением минимальной стоимости для каждой мощности; и для нужной мощности всегда предоставляется цена кондиционера, таким образом ответ будет найден.   
      Сложность = O(N + M + K).   

**Операции робота.** Определить количество экономически целесообразных способов использования робота. Робот имеет память, необходимо выполнить список операций. Использование робота экономически целесообразно, если он выполнит хотя бы размер_памяти + 1 операцию. Счетчик совпадений подряд, увеличения счетчика способов на количество совпадений подряд, сдвиг окна (указателя), сравнение элементов по шагу.    
Сложность = O(N).  
</br>
**Количество равнобедренных треугольников.** Определить сколько равнобедренных треугольников можно построить с помощью данных координат. Чтение данных при инициализации массива; перебор каждой точки как начала системы координат; список расстояний до каждой точки; множество вершин для проверка точек на одной линии; расчет координаты от нового начала системы координат; определение квадрата расстояния; проверка, что точка не лежит на одной прямой с другой точкой; сортировка расстояний; двигаем левый указатель на 1 по каждой точке; двигаем правый указатель до следующего значения расстояния в списке; определение количества равнобедренных треугольников с текущей стороной.   
Для оптимизации по времени: массив координа, чтение данных при инициализации массива, длина Long для защиты от переполнения.   
Сложность = O(N^2 * logN).  
</br>
**Количество вариаций счета игры.** Определить количество различных вариаций счета (a:b:c) с указанной максимальной разницей. Определение количество уникальных карточек счета; сортировка уникальных карточек; левый указатель - уникальная карта счета; правый указатель - максимальная допустимая уникальная карточка счета; каждую итерацию двигаем левый указатель на 1; правый указатель сохраняет свою позицию и двигается до максимальной допустимой карточки; рассчитываем количество дублирующих карточек счета; определение количество вариаций счета: с разными карточками, с дублированием текущий карточки, с дублированием другой карточки, только текущая карточка.   
Сложность = O(N + M * logM).  
</br>
**Максимальная подстрока.** Определить длину максимальной подстроки и индекс ее начала. Символ в подстроке может повторяться ограниченное количество раз. Метод двух указателей (скользящее окно); правый указатель (конец подстроки) - расширяет окно, каждый раз сдвигается на 1; левый указатель (начало подстроки) - сокращает окно, если подстрока не подходит; для каждого конечного символа определяется максимальная подстрока. Символы и число их повторений хранится в словаре; после определения размера окна, высчитывается длина подстроки.     
Сложность = O(N).  
</br>


</br></br></br></br>

## Задание 6. Бинарный поиск - 9 из 11.

**Проверка наличия числа в массиве.** Определить наличие каждого из списка числе в массиве чисел.  
   1) Проверка каждого числа на наличие в массиве; левый бинарный поиск - первый элемент >= числу; сохранение результата проверки в списке строк.  
      Сложность = O(K * logN).  
   2) Если массив не упорядочен, то требуется сортировка по возрастанию, чтобы можно было использовать бинарный поиск.  
      Сложность = O(N * logN + K * logN).  
   3) Использовать множество, вместо бинарного поиска; хранит все числа без повторений и быстрая проверка наличия числа в множестве.  
      Сложность = O(N + K).  

**Ближайшее число в массиве.** Определить для каждого числа из списка ближайшее к нему число из массива.  
   1) Пробег по всем числам; два бинарных поиска; левый бинарный поиск - наименьший из элементов, которые >= числу; правый бинарный поиск - наибольший из элементов, которые <= числу; сравнение степени близости найденных элементов к числу.  
      Сложность = O(K * logN).  
   2) Определить позицию вставки в отсортированный массив каждого числа; сравнение соседних элементов (предыдущий и найденный индекс) на близость к числу; один бинарный поиск.  
      Сложность = O(K * logN).   

**Размер мебели для размещения вещей.** Определить минимальный размер доски, чтобы разместить все грамоты.   
   1) Не обязательно хранить все возможные размеры доски в массиве; установить максимальный размер = кол-во дипломов * высоту или ширину диплома; левый бинарный поиск - наименьший размер доски, так как все большие размеры точно подходят для размещения дипломов; проверка на размещения дипломов - определение сколько можно расположить дипломов с указанным размером доски по ширине и по высоте, затем перемножить и проверить на соответствие количеству дипломов.        
      Сложность = O(logM).   
   2) Можно вычислить правый указатель в цикле с помощью проверки на соответствие: начальное значение 1, пока не подходит размер умножать в цикле на 2 правыую границу, таким образом найдем размер доски, который точно подходит.  
      Сложность = O(2 * logS) = O(logS).   

**Размеры защиты для вещей.** Определить максимальный размер защиты для модуля, модули имеют свои размеры и располагаются в поле как отдельные здания. 
   1) Максимальный размер защиты - ширина или длина поля; правый бинарный поиск - максимальный размер защиты, так как все меньшие размеры точно подходят для размещения модулей в поле; проверка на размещения модулей в поле: определение размеров модуля по длине и ширине с установленной защитой, определение количество модулей которых можно разместить по высоте и ширине (в стандартном виде и при развороте на 90 градусов), проверка на соответствие общему числу модулей.    
      Сложность = O(logM).   
   2) Можно вычислить правый указатель в цикле до несоответствия (экспотенциальный поиск верхней границы): начальное значение 1, пока подходит размер умножать в цикле на 2 правыую границу, таким образом найдем размер минимальной недопустимой защиты модуля.    
      Сложность = O(logD).   

**Время печати копий.** Определить минимальное время в секундах для получения определенного количества копий с помощью 2 сканеров. Максимальное время копирования (правая граница) - время копирования всех копий на одном принтере; из-за близости левой границы к правой может произойти переполнение; левый бинарный поиск - минимальное время на копирование, большее время точно приведет к большему числу копий; расчет времени на первую копию (для старта второго принтера - два экземпляра); проверка не закончилось ли время, пока печаталась первая копия; определение оставшегося времени после первой копии; расчет количество копий при работе на двух принтерах за оставшееся время; проверка уложились ли в нужное количество копий за отведенное время.     
Сложность = O(logN).   
</br>

**Исправление оценки.** Определить минимальное количество пятерок, которые нужно получить, чтобы исправить итоговую оценку. Дано количество двоек, троек, четверок. Максимальное количество пятерок (правая граница) - количество оценок, которые нужно исправить (двойки и тройки); левый бинарный поиск - минимальное количество пятерок для исправления итоговой оценки, большее точно приведет к увеличению среднего балла; убрана работа с вещественными числами с помощью умножения крест на крест. Можно решить аналитически (проще и эффективнее).   
Сложность = O(log(A+B)).   
</br>

**Разделение объектов на равные части.** Определить максимальную длину отрезка при делении на определенное количество отрезков всех проводов. Максимальная длина отрезка (правая граница) - максимальная длина самого длинного провода; правый бинарный поиск - максимальная длина отрезка, на которое можно разделить все провода и получить нужное количество отрезков (на меньшую длину точно получится разделить); правый бинарный поиск не позволит разделить на ноль (минимальную возможную длину отрезка); при проверка пробегаемся по всем проводам и делим на определенную длину отрезка.   
Сложность = O(N * logM).   
</br>

**Ширина дорожки из плитки.** Определить максимальную ширину дорожки из плитки. Максимальная длина отрезка (правая граница) - ширина или длина площади деленная на 2; правый бинарный поиск - максимальная ширина дорожки, на которую хватит плитки (на меньшую ширину точно хватит); проверка осуществляется с помощью разницы площади территории и площади клумбы; перебирается ширина дорожки.   
Сложность = O(logN).   
</br>

**Копмлектация учеников в бригады.** Укомплектовать определенное количество бригад школьниками, и определить наименьшее возможное значение максимального числа неудобства сформированных бригад. Числом неудобства бригады будем называть разность между ростом самого высокого и ростом самого низкого членов этой бригады. Правая граница (максимальная разница в росте) - разница в росте между самым высоким учеником и самым низник учеником в классе; левый бинарный поиск - наименьшая возможная разница (значение больше точно допустио); предварительная сортировка учеников по росту; для проверки проходим по всем ученикам с шагом, и проверяем можно ли составить из текущих учеников бригаду; если можно переходим к следующей возможной, иначе проверяем следующего ученика по росту; считаем сколько можно составить бригад с определенным удобством; используется жадный алгоритм - подходит ли значения (а не определяет наилучшее), локальный оптимальный выбор.   
Сложность = O(N * logN + N * logM).   
</br>


</br></br></br></br>

## Задание 7. Сортировка событий - 1 из 10.

**Списывание экзамена.** Наблюдение за партами. Сортировка списка по началу интервала, сравнение концов интервала для информации о пересечении интервалов.  
Сложность = O(M * log M).  
